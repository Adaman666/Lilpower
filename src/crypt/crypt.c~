/**
 *	crypt.c Fichier source de la lib de cryptage du projet Lilpower
 *
 *	propriété de Loïc Dalloz, Alexandre Brand, Jean-Charles Blind, Arthur Declerq et Romain Brewee
 *
 */

#include "cript.h"

/** fonctions de cryptage du projet Lilpower. */

/**
 *	fonction de creation d'une cle publique
 *
 *	@param: cle a contenir
 *
 *	@retour: adresse de la structure cle ainsi creee
 */
crypt_key* crypt_create_public(unsigned long double e, unsigned long double n)
{
	//ressources
	crypt_key* k = NULL;

	//allocation de la cle:
	k = (crypt_key*)malloc(sizeof(crypt_key));
	if(!k){
		perror("****fatal error****\nin crypt_create_public ");
		exit(EXIT_FAILURE);}

	//remplissage de la structure
	k->type = PUBLIC;
	k->e = e;
	k->n = n;
	k->p = 0;
	k->q = 0;
	k->f = 0;
	k->d = 0;

	return k;
}

/**
 *	fonction de crÃ©ation d'une clÃ©e privÃ©e et de sa clÃ©e publique associÃ©e.
 *
 *	@param: pointeur sur le pointeur de la clÃ©e publique
 *
 *	@retour: adresse de la structure clÃ©e ainsi crÃ©Ã©e
 */
crypt_key* crypt_create_private(crypt_key** public_key)
{
	//ressources
	crypt_key* pr_k = NULL;
	unsigned long double p, q, f, n, e, d;
	int k;

	//allocation de la strucure clÃ© privÃ©e
	pr_k = (crypt_key*)malloc(sizeof(crypt_key));
	if(!pr_k){
		perror("****fatal error****\nin crypt_create_public ");
		exit(EXIT_FAILURE);}

	//creation des cles
	//récupération de p et q :
	p = crypt_find_prem(32);
	q = crypt_find_prem(32);
	//calcul de n et f :
	n = p*q;
	f = (p-1)*(q-1);
	//récupération de e :
	e = crypt_find_prem_other(32, n, f);
	//calul de d :
	k = 1;
	do{
		k++;
	}while(((k*f)-1)%e != 0);
	d = ((k*f)-1)/e;

	//remplissage :
	*public_key = crypt_create_public(e, n);

	pr_k->type = PRIVATE;
	pr_k->p = p;
	pr_k->q = q;
	pr_k->f = f;
	pr_k->n = n;
	pr_k->e = e;
	pr_k->d = d;

	return pr_k;
}

/**
 *	fonction d'encryptage d'un message :
 *
 *	@param: message -> message Ã  encrypter
 *		public_key -> clÃ©e privÃ©e Ã  utiliser pour encrypter le message
 *
 *	@retour: message encryptÃ©
 */
char* crypt_encrypt(char* message, crypt_key* public_key)
{
	//ressources
	int size, i;
	char* buffer;
	
	//récupétation de la taille du message :
	size = sizeof(*message);
}

/**
 *	fonction de dÃ©cryptage d'un message :
 *
 *	@param: message -> message Ã  dÃ©crypter
 *		private_key -> clÃ©e privÃ©e Ã  utiliser pour dÃ©crypter le message
 *
 *	@retour: message dÃ©cryptÃ©
 */
char* crypt_decrypt(char* message, crypt_key* private_key)
{
	//ressources
	
	//TODO
}

/**
 *	fonction de recherche de nombre premier en fonction d'autres nombres
 *
 *	@param: size -> taille min (en bit) du nombre à trouver (max : sizeof(double) sur une machine 32bit)
 *		a -> nombre avec lequel le nombre doit être premier (0 par défaut)
 *		b -> comme a
 *
 *	@retour: numéro retourné
 */
static unsigned long double crypt_find_prem_other(int size, int a, int b)
{

	//ressources
	unsigned long double number;

	if(a == 0)
	{
		//...
	}
	else
	{
		if(b==0)
		{
			//...
		}
		else
		{
			//...
		}
	}
 	
	return number;
}

/**
 *	fonction de recherche d'un nombre premier
 *
 *	@param: size -> taille min (en bit) du nombre a trouver (max : sizeof(double) sur machine 32bit) 
 *
 *	@retour: nombre premier trouvé
 *
 *	Attention : les nombres premiers sont lus dans le fichier prem.txt
 */
static unsigned long double crypt_find_prem(int size)
{
	//ressources
	unsigned long double nbr, min, tmp, pres;
	int err;
	FILE* prem = NULL

	//ouverture du fichier
	prem = fopen("prem.txt", "r");
	if(!prem){perror("***FATAL ERROR*** when loading prem.txt file ");exit(EXIT_FAILURE);}
	
	/** recherche */
	//calcul du nombre minumum:
	min = 1;
	min = min << size;

	//recherche des nombres supérieurs à cette valeur :
	do{
		err = fscanf(prem, "%Ld", &tmp);
	}while((tmp < min) && (err == 1));
	//si fin de fichier prématuré :
	if(err == 0){printf("***FATAL ERROR*** when reading prem.txt file : the time to reach the end of file is too short.\n\n");exit(EXIT_FAILURE);}

	//sélection du nombre premier (une chance sur 4)
	nbr = 0;
	do{
		err = fscanf(prem, "%Ld", &tmp);
		if(rand()%4 == 0)
			nbr = tmp;
	}while((nbr == 0) && (err != 0));
	if(nbr == 0)
		nbr = tmp;

	//fermeture du fichier
	fclose(prem);

	return nbr;
}
